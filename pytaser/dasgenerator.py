#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Aug  3 16:42:36 2023

@author: lucasverga
"""

import itertools
from tqdm import tqdm
import warnings
import numpy as np
from multiprocessing import Pool, cpu_count

from pymatgen.electronic_structure.core import Spin
from pymatgen.electronic_structure.dos import FermiDos, f0
from pymatgen.ext.matproj import MPRester
from pymatgen.io.vasp import optics
from pymatgen.io.vasp.inputs import UnknownPotcarWarning
from pymatgen.io.vasp.outputs import Vasprun, Waveder

from pytaser.kpoints import get_kpoint_weights
from pytaser.tas import Tas
from pytaser.das import Das
import pytaser.generator as generator
import pytaser.createinternalDas as InternalDas

warnings.filterwarnings("ignore", category=RuntimeWarning)

class DASGenerator:
    """
    Class to generate a TAS spectrum (decomposed and cumulative) from a bandstructure and
    dos object.

    Args:
        bs: Pymatgen-based bandstructure object
        kpoint_weights: kpoint weights either found by the function or inputted.
        dos: Pymatgen-based dos object
        dfc: Pymatgen-based DielectricFunctionCalculator object (for computing oscillator strengths)

    Attributes:
        bs: Pymatgen bandstructure object
        kpoint_weights: k-point weights (degeneracies).
        dos: Pymatgen-based dos object
        dfc: Pymatgen-based DielectricFunctionCalculator object (for computing oscillator strengths)
        bg_centre: Energy (eV) of the bandgap centre.
        vb: Spin dict detailing the valence band maxima.
        cb: Spin dict detailing the conduction band minima
    """

    def __init__(self, newSystem, referenceSystem,):
        
        self.newSystem = newSystem
        self.referenceSystem = referenceSystem           

    @classmethod
    def from_vasp_outputs(cls, vasprun_file_newSystem,vasprun_file_ref, waveder_file_newSystem=None,waveder_file_ref=None):
        """Create a TASGenerator object from VASP output files."""
        warnings.filterwarnings("ignore", category=UnknownPotcarWarning)
        warnings.filterwarnings("ignore", message="No POTCAR file with matching TITEL fields")

        newSystem = createinternalDas.internalAS.internal_from_vasp(vasprun_file_newSystem,waveder_file_newSystem)
        referenceSystem = createinternalDas.internalAS.internal_from_vasp(vasprun_file_ref,waveder_file_ref) 
                  
        return cls(newSystem, referenceSystem)
 

    @classmethod
    def from_mpid(cls, mpid, mpid_ref, bg=None, bg_ref=None, api_key=None, mpr=None,mpr_ref=None):
        """
        Import the desired bandstructure and dos objects from the legacy Materials Project
        database.

        Args:
            mpid: The Materials Project ID of the desired material.
            bg: The experimental bandgap (eV) of the material. If None, the band gap
                of the MP calculation will be used.
            api_key: The user's Materials Project API key.
            mpr: An MPRester object if already generated by user.

        Returns:
            A TASGenerator object.
        """
        newSystem = createinternalDas.internalAS.internal_from_mpid( mpid, bg=None, api_key=None, mpr=None)
        referenceSystem = createinternalDas.internalAS.internal_from_mpid(mpid_ref,bg_ref,api_key=None, mpr_ref=None))         
        
        return cls(newSystem, referenceSystem)

    def generate_das(
        self,
        temp,
        conc,
        energy_min=0,
        energy_max=5,
        gaussian_width=0.1,
        cshift=None,
        step=0.01,
        light_occs=None,
        dark_occs=None,
        processes=None,
    ):
        """
        Generates TAS spectra based on inputted occupancies, and a specified energy mesh. If the
        TASGenerator has not been generated from VASP outputs (and thus does not have a dfc
        attribute), then the output TAS is generated using the change in joint density of states
        (JDOS) under illumination, with no consideration of oscillator strengths.
        Otherwise, the output TAS is generated considering all contributions to the predicted TAS
        spectrum.

        Args:
            temp: Temperature (K) of material we wish to investigate (affects the FD distribution)
            conc: Carrier concentration (cm^-3) of holes and electrons (both are equivalent).
                Inversely proportional to pump-probe time delay.
            energy_min: Minimum band transition energy to consider for energy mesh (eV)
            energy_max: Maximum band transition energy to consider for energy mesh (eV)
            gaussian_width: Width of gaussian curve
            cshift: Complex shift in the Kramers-Kronig transformation of the dielectric function
                (see https://www.vasp.at/wiki/index.php/CSHIFT). If not set, uses the value of
                CSHIFT from the underlying VASP WAVEDER calculation. (only relevant if the
                TASGenerator has been generated from VASP outputs)
            step: Interval between energy points in the energy mesh.
            light_occs: Optional input parameter for occupancies of material under light, otherwise
                automatically calculated based on input temperature (temp) and carrier concentration
                (conc) [dict]
            dark_occs: Optional input parameter for occupancies of material in dark, otherwise
                automatically calculated based on input temperature (temp) and carrier concentration
                (conc) [dict]
            processes: Number of processes to use for multiprocessing. If not set, defaults to one
                less than the number of CPUs available.

        Returns:
            TAS class containing the following inputs;
                - tas_total: overall deltaT TAS spectrum for a material under the
                    specified conditions.
                - jdos_diff_if: JDOS difference (from dark to light) across the energy mesh for a
                    specific band transition i (initial) -> f (final) [dict]
                - jdos_light_total: overall JDOS (pump-on) for a material under the
                    specified conditions
                - jdos_light_if: JDOS (pump-on) across the energy mesh for a specific band
                    transition i (initial) -> f (final) [dict]
                - jdos_dark_total: overall JDOS (pump-off) for a material under the
                    specified conditions
                - jdos_dark_if: JDOS (pump-off) across the energy mesh for a specific band
                    transition i (initial) -> f (final) [dict]
                - energy_mesh_ev: Energy mesh of spectra in eV, with an interval of 'step'.
                - bandgap: Bandgap of the system, in eV, rounded to 2 decimal points
                - temp: Temperature of the system, in K
                - conc: Carrier concentration of the system, in cm^-3
                - alpha_dark: Absorption coefficient of the material in the dark, in cm^-1 (only
                    calculated if the TASGenerator has been generated from VASP outputs)
                - alpha_light_dict: Dictionary of band-to-band absorption, stimulated emission
                    and summed contributions to the total overall absorption coefficient under
                    illumination, in cm^-1 (only calculated if the TASGenerator has been
                    generated from VASP outputs)
                - weighted_jdos_diff_if: JDOS difference (from dark to light) across the energy
                    mesh for a specific band transition i (initial) -> f (final), weighted by the
                    oscillator strength of the transition [dict]
                - weighted_jdos_light_if: JDOS (pump-on) across the energy mesh for a specific band
                    transition i (initial) -> f (final), weighted by the oscillator strength of
                    the transition [dict]
                - weighted_jdos_dark_if: JDOS (pump-off) across the energy mesh for a specific band
                    transition i (initial) -> f (final), weighted by the oscillator strength of
                    the transition [dict]
        """
        bandgap = round(self.referenceSystem.bs.get_band_gap()["energy"], 2)
        energy_mesh_ev = np.arange(energy_min, energy_max, step)
        jdos_light_if = {}
        jdos_dark_if = {}
        jdos_diff_if = {}
        weighted_jdos_light_if = {}
        weighted_jdos_dark_if = {}
        weighted_jdos_diff_if = {}
        tas_total = np.zeros(len(energy_mesh_ev))
        jdos_dark_total = np.zeros(len(energy_mesh_ev))
        jdos_light_total = np.zeros(len(energy_mesh_ev))


        egrid_ref = np.arange(
            0, self.referenceSystem.dfc.nedos * self.referenceSystem.dfc.deltae, self.referenceSystem.dfc.deltae
        )
        if len(egrid_ref)>self.referenceSystem.dfc.nedos:
            egrid_ref=np.delete(egrid_ref, len(egrid_ref)-1)

        egrid = np.arange(
            0, self.newSystem.dfc.nedos * self.newSystem.dfc.deltae, self.newSystem.dfc.deltae
        )
        if len(egrid)>self.newSystem.dfc.nedos:
            egrid=np.delete(egrid, len(egrid)-1)


        alpha_dark = np.zeros_like(egrid_ref, dtype=np.complex128)
        alpha_light = np.zeros_like(egrid, dtype=np.complex128)
        


            

        jdos_dark_total,jdos_dark_if,alpha_dark,weighted_jdos_dark_if=createInternalDas.internalAS.generate_AS(self.referenceSystem,
                                                                                        temp,
                                                                                        conc,
                                                                                        energy_min=0,
                                                                                        energy_max=5,
                                                                                        gaussian_width=0.1,
                                                                                        cshift=None,
                                                                                        step=0.01,
                                                                                        light_occs=None,
                                                                                        dark_occs=None,
                                                                                        processes=None,)
        
        jdos_light_total,jdos_light_if,alpha_light,weighted_jdos_light_if=createInternalDas.internalAS.generate_AS(self.newSystem,
                                                                                        temp,
                                                                                        conc,
                                                                                        energy_min=0,
                                                                                        energy_max=5,
                                                                                        gaussian_width=0.1,
                                                                                        cshift=None,
                                                                                        step=0.01,
                                                                                        light_occs=None,
                                                                                        dark_occs=None,
                                                                                        processes=None,)            
                    

        tas_total = jdos_light_total-jdos_dark_total 
               
        # need to interpolate alpha arrays onto JDOS energy mesh:
        if self.dfc is not None:
            alpha_dark = np.interp(energy_mesh_ev, egrid_ref, alpha_dark)
            alpha_light = np.interp(energy_mesh_ev, egrid, alpha_light)           
            tas_total = (alpha_light-alpha_dark)    
            

        return Das(
            tas_total,
            jdos_diff_if,
            jdos_light_total,
            jdos_light_if,
            jdos_dark_total,
            jdos_dark_if,
            energy_mesh_ev,
            bandgap,
            temp,
            conc,
            alpha_dark if self.dfc is not None else None,
            alpha_light_dict if self.dfc is not None else None,
            weighted_jdos_light_if if self.dfc is not None else None,
            weighted_jdos_dark_if if self.dfc is not None else None,
            weighted_jdos_diff_if if self.dfc is not None else None,
        )

